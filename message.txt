import math
import streamlit as streamlit
import pandas as pandas
import pydeck as pydeck

try:
    import folium
    from streamlit_folium import st_folium

    folium_is_available = True
except Exception:
    folium_is_available = False


class CentroidCalculator:
    def __init__(self, points=None):
        self._pts = []
        if points:
            self.extend(points)
    def add(self, x, y, transport_rate, mass):
        self._pts.append((float(x), float(y), float(transport_rate), float(mass)))
    def extend(self, points):
        for p in points:
            self._pts.append((float(p[0]), float(p[1]), float(p[2]), float(p[3])))
    def centroid(self):
        points_list = list(self._pts)
        if not points_list:
            return 0.0, 0.0
        total_weight = 0.0
        weighted_x_sum = 0.0
        weighted_y_sum = 0.0
        for x_coordinate, y_coordinate, transport_rate, mass in points_list:
            point_weight = float(transport_rate) * float(mass)
            total_weight += point_weight
            weighted_x_sum += point_weight * float(x_coordinate)
            weighted_y_sum += point_weight * float(y_coordinate)
        if abs(total_weight) < 1e-12:
            points_count = len(points_list)
            if points_count == 0:
                return 0.0, 0.0
            average_x = sum(p[0] for p in points_list) / points_count
            average_y = sum(p[1] for p in points_list) / points_count
            return float(average_x), float(average_y)
        centroid_x = weighted_x_sum / total_weight
        centroid_y = weighted_y_sum / total_weight
        return float(centroid_x), float(centroid_y)
    def weighted_euclidean_distance_sum(self, centroid_x, centroid_y):
        points_list = list(self._pts)
        if not points_list:
            return 0.0
        weighted_distance_sum = 0.0
        for x_coordinate, y_coordinate, transport_rate, mass in points_list:
            point_weight = float(transport_rate) * float(mass)
            euclidean_distance = math.sqrt((float(centroid_x) - float(x_coordinate)) ** 2 + (float(centroid_y) - float(y_coordinate)) ** 2)
            weighted_distance_sum += point_weight * euclidean_distance
        return float(weighted_distance_sum)


def normalize_column_names(input_dataframe):
    normalized_dataframe = input_dataframe.copy()
    normalized_dataframe.columns = [str(column).strip().lower() for column in normalized_dataframe.columns]
    return normalized_dataframe


def choose_existing_column(normalized_dataframe, candidate_names):
    for candidate_name in candidate_names:
        if candidate_name in normalized_dataframe.columns:
            return candidate_name
    return None


def ensure_points_dataframe(points_dataframe):
    if points_dataframe is None:
        return pandas.DataFrame(columns=["longitude", "latitude", "transport_rate", "mass"])
    normalized_dataframe = normalize_column_names(points_dataframe)

    longitude_column = choose_existing_column(normalized_dataframe, ["longitude", "lon", "x"])
    latitude_column = choose_existing_column(normalized_dataframe, ["latitude", "lat", "y"])
    transport_rate_column = choose_existing_column(normalized_dataframe, ["transport_rate", "transport", "rate", "stawka_transportowa", "stawka", "st"])
    mass_column = choose_existing_column(normalized_dataframe, ["mass", "masa", "m"])

    if longitude_column is None or latitude_column is None:
        if len(normalized_dataframe.columns) >= 2:
            inferred_longitude_column = normalized_dataframe.columns[0]
            inferred_latitude_column = normalized_dataframe.columns[1]
            longitude_column = longitude_column or inferred_longitude_column
            latitude_column = latitude_column or inferred_latitude_column

    if transport_rate_column is None:
        normalized_dataframe["transport_rate"] = 1.0
        transport_rate_column = "transport_rate"

    if mass_column is None:
        normalized_dataframe["mass"] = 1.0
        mass_column = "mass"

    if longitude_column is None:
        normalized_dataframe["longitude"] = []
        longitude_column = "longitude"
    if latitude_column is None:
        normalized_dataframe["latitude"] = []
        latitude_column = "latitude"

    selected_dataframe = normalized_dataframe[[longitude_column, latitude_column, transport_rate_column, mass_column]].copy()
    selected_dataframe.columns = ["longitude", "latitude", "transport_rate", "mass"]

    selected_dataframe["longitude"] = pandas.to_numeric(selected_dataframe["longitude"], errors="coerce")
    selected_dataframe["latitude"] = pandas.to_numeric(selected_dataframe["latitude"], errors="coerce")
    selected_dataframe["transport_rate"] = pandas.to_numeric(selected_dataframe["transport_rate"], errors="coerce")
    selected_dataframe["mass"] = pandas.to_numeric(selected_dataframe["mass"], errors="coerce")

    selected_dataframe = selected_dataframe.dropna(subset=["longitude", "latitude"]).reset_index(drop=True)
    selected_dataframe["transport_rate"] = selected_dataframe["transport_rate"].fillna(1.0)
    selected_dataframe["mass"] = selected_dataframe["mass"].fillna(1.0)

    return selected_dataframe


def append_point(points_dataframe, longitude, latitude, transport_rate, mass):
    updated_points_dataframe = ensure_points_dataframe(points_dataframe)
    new_row_dataframe = pandas.DataFrame([{"longitude": float(longitude), "latitude": float(latitude), "transport_rate": float(transport_rate), "mass": float(mass)}])
    updated_points_dataframe = pandas.concat([updated_points_dataframe, new_row_dataframe], ignore_index=True)
    return updated_points_dataframe


def read_points_from_uploaded_file(uploaded_file):
    if uploaded_file is None:
        return pandas.DataFrame(columns=["longitude", "latitude", "transport_rate", "mass"])
    uploaded_name = str(uploaded_file.name).lower()
    try:
        if uploaded_name.endswith(".csv"):
            uploaded_dataframe = pandas.read_csv(uploaded_file)
        elif uploaded_name.endswith(".xlsx") or uploaded_name.endswith(".xls"):
            uploaded_dataframe = pandas.read_excel(uploaded_file)
        else:
            uploaded_dataframe = pandas.read_csv(uploaded_file)
    except Exception:
        return pandas.DataFrame(columns=["longitude", "latitude", "transport_rate", "mass"])
    return ensure_points_dataframe(uploaded_dataframe)


def compute_center_of_gravity(points_dataframe):
    points_dataframe = ensure_points_dataframe(points_dataframe)
    centroid_calculator = CentroidCalculator()
    for _, row in points_dataframe.iterrows():
        centroid_calculator.add(row["longitude"], row["latitude"], row["transport_rate"], row["mass"])
    centroid_longitude, centroid_latitude = centroid_calculator.centroid()
    weighted_distance_sum = centroid_calculator.weighted_euclidean_distance_sum(centroid_longitude, centroid_latitude)
    return centroid_longitude, centroid_latitude, weighted_distance_sum


def get_map_center(points_dataframe, centroid_longitude, centroid_latitude):
    points_dataframe = ensure_points_dataframe(points_dataframe)
    if len(points_dataframe) > 0:
        last_point_longitude = float(points_dataframe.iloc[-1]["longitude"])
        last_point_latitude = float(points_dataframe.iloc[-1]["latitude"])
        return last_point_longitude, last_point_latitude
    if abs(float(centroid_longitude)) > 1e-9 or abs(float(centroid_latitude)) > 1e-9:
        return float(centroid_longitude), float(centroid_latitude)
    return 21.0122, 52.2297


def build_polyline_path(points_dataframe):
    points_dataframe = ensure_points_dataframe(points_dataframe)
    polyline_path = []
    for _, row in points_dataframe.iterrows():
        polyline_path.append([float(row["longitude"]), float(row["latitude"])])
    if len(polyline_path) >= 3 and polyline_path[0] != polyline_path[-1]:
        polyline_path.append(polyline_path[0])
    return polyline_path


def compute_point_distances(points_dataframe, centroid_longitude, centroid_latitude):
    points_dataframe = ensure_points_dataframe(points_dataframe)
    distances_dataframe = points_dataframe.copy()
    distances = []
    weighted_distances = []
    for _, row in distances_dataframe.iterrows():
        euclidean_distance = math.sqrt((float(centroid_longitude) - float(row["longitude"])) ** 2 + (float(centroid_latitude) - float(row["latitude"])) ** 2)
        point_weight = float(row["transport_rate"]) * float(row["mass"])
        distances.append(float(euclidean_distance))
        weighted_distances.append(float(point_weight) * float(euclidean_distance))
    distances_dataframe["euclidean_distance"] = distances
    distances_dataframe["weighted_euclidean_distance"] = weighted_distances
    return distances_dataframe


streamlit.set_page_config(page_title="Środek ciężkości logistyczny", layout="wide")

if "points_dataframe" not in streamlit.session_state:
    streamlit.session_state["points_dataframe"] = pandas.DataFrame(columns=["longitude", "latitude", "transport_rate", "mass"])

if "last_clicked_longitude" not in streamlit.session_state:
    streamlit.session_state["last_clicked_longitude"] = None

if "last_clicked_latitude" not in streamlit.session_state:
    streamlit.session_state["last_clicked_latitude"] = None

streamlit.title("Lokalizacja punktu logistycznego metodą środka ciężkości")
streamlit.write("Współrzędne wyznaczane są wzorami: X = Σ(ST·M·X) / Σ(ST·M) oraz Y = Σ(ST·M·Y) / Σ(ST·M). Odległości liczone są metryką euklidesową: d = √((X−Xn)² + (Y−Yn)²).")

control_column, map_column = streamlit.columns([1, 2], gap="large")

with control_column:
    streamlit.subheader("Dane wejściowe")
    uploaded_file = streamlit.file_uploader("Wczytaj punkty z pliku (CSV/XLSX). Kolumny: longitude/latitude oraz opcjonalnie transport_rate/mass", type=["csv", "xlsx", "xls"])
    if uploaded_file is not None:
        uploaded_points_dataframe = read_points_from_uploaded_file(uploaded_file)
        if len(uploaded_points_dataframe) > 0:
            streamlit.session_state["points_dataframe"] = uploaded_points_dataframe

    points_dataframe = ensure_points_dataframe(streamlit.session_state["points_dataframe"])

    data_editor_function = getattr(streamlit, "data_editor", None)
    if data_editor_function is not None:
        edited_points_dataframe = data_editor_function(
            points_dataframe,
            num_rows="dynamic",
            use_container_width=True
        )
        streamlit.session_state["points_dataframe"] = ensure_points_dataframe(edited_points_dataframe)
        points_dataframe = ensure_points_dataframe(streamlit.session_state["points_dataframe"])
    else:
        streamlit.dataframe(points_dataframe, use_container_width=True)

    streamlit.divider()
    streamlit.subheader("Dodaj punkt ręcznie")
    manual_longitude = streamlit.number_input("X (longitude)", value=21.012200, format="%.6f")
    manual_latitude = streamlit.number_input("Y (latitude)", value=52.229700, format="%.6f")
    manual_transport_rate = streamlit.number_input("ST (stawka transportowa)", value=1.000000, min_value=0.0, format="%.6f")
    manual_mass = streamlit.number_input("M (masa)", value=1.000000, min_value=0.0, format="%.6f")
    add_manual_point_button = streamlit.button("Dodaj punkt", use_container_width=True)

    if add_manual_point_button:
        streamlit.session_state["points_dataframe"] = append_point(streamlit.session_state["points_dataframe"], manual_longitude, manual_latitude, manual_transport_rate, manual_mass)

    clear_points_button = streamlit.button("Wyczyść wszystkie punkty", use_container_width=True)
    if clear_points_button:
        streamlit.session_state["points_dataframe"] = pandas.DataFrame(columns=["longitude", "latitude", "transport_rate", "mass"])
        streamlit.session_state["last_clicked_longitude"] = None
        streamlit.session_state["last_clicked_latitude"] = None

    points_dataframe = ensure_points_dataframe(streamlit.session_state["points_dataframe"])
    centroid_longitude, centroid_latitude, weighted_distance_sum = compute_center_of_gravity(points_dataframe)

    streamlit.divider()
    streamlit.subheader("Wynik")
    if len(points_dataframe) == 0:
        streamlit.info("Dodaj co najmniej jeden punkt, aby wyliczyć X i Y.")
    else:
        streamlit.metric("X (longitude)", f"{centroid_longitude:.6f}")
        streamlit.metric("Y (latitude)", f"{centroid_latitude:.6f}")
        streamlit.metric("Suma ważona odległości euklidesowych", f"{weighted_distance_sum:.6f}")

        distances_dataframe = compute_point_distances(points_dataframe, centroid_longitude, centroid_latitude)
        streamlit.subheader("Odległości (metryka euklidesowa)")
        streamlit.dataframe(distances_dataframe, use_container_width=True)

with map_column:
    points_dataframe = ensure_points_dataframe(streamlit.session_state["points_dataframe"])
    centroid_longitude, centroid_latitude, weighted_distance_sum = compute_center_of_gravity(points_dataframe)
    map_center_longitude, map_center_latitude = get_map_center(points_dataframe, centroid_longitude, centroid_latitude)
    polyline_path = build_polyline_path(points_dataframe)

    streamlit.subheader("Mapa")
    if folium_is_available:
        folium_map = folium.Map(location=[map_center_latitude, map_center_longitude], zoom_start=11, control_scale=True)

        if len(polyline_path) >= 4:
            folium.PolyLine(
                locations=[[latitude, longitude] for longitude, latitude in polyline_path],
                weight=3
            ).add_to(folium_map)

        for _, row in points_dataframe.iterrows():
            point_weight = float(row["transport_rate"]) * float(row["mass"])
            folium.CircleMarker(
                location=[float(row["latitude"]), float(row["longitude"])],
                radius=5,
                fill=True,
                popup=f"X={float(row['longitude']):.6f}, Y={float(row['latitude']):.6f}, ST={float(row['transport_rate']):.6f}, M={float(row['mass']):.6f}, ST·M={point_weight:.6f}"
            ).add_to(folium_map)

        if len(points_dataframe) > 0:
            folium.CircleMarker(
                location=[float(centroid_latitude), float(centroid_longitude)],
                radius=14,
                color="red",
                fill=True,
                fill_color="red",
                fill_opacity=0.95,
                popup=f"Punkt obliczeń: Y={centroid_latitude:.6f}, X={centroid_longitude:.6f}"
            ).add_to(folium_map)

        map_interaction = st_folium(folium_map, height=600, use_container_width=True)

        last_clicked = None
        if isinstance(map_interaction, dict):
            last_clicked = map_interaction.get("last_clicked")

        if isinstance(last_clicked, dict) and "lng" in last_clicked and "lat" in last_clicked:
            streamlit.session_state["last_clicked_longitude"] = float(last_clicked["lng"])
            streamlit.session_state["last_clicked_latitude"] = float(last_clicked["lat"])

        last_clicked_longitude = streamlit.session_state["last_clicked_longitude"]
        last_clicked_latitude = streamlit.session_state["last_clicked_latitude"]

        if last_clicked_longitude is not None and last_clicked_latitude is not None:
            streamlit.write(f"Ostatnie kliknięcie: Y={last_clicked_latitude:.6f}, X={last_clicked_longitude:.6f}")
            clicked_transport_rate = streamlit.number_input("ST dla punktu z mapy", value=1.000000, min_value=0.0, format="%.6f", key="clicked_transport_rate_input")
            clicked_mass = streamlit.number_input("M dla punktu z mapy", value=1.000000, min_value=0.0, format="%.6f", key="clicked_mass_input")
            add_clicked_point_button = streamlit.button("Dodaj punkt z mapy", use_container_width=True)
            if add_clicked_point_button:
                streamlit.session_state["points_dataframe"] = append_point(streamlit.session_state["points_dataframe"], last_clicked_longitude, last_clicked_latitude, clicked_transport_rate, clicked_mass)
                streamlit.session_state["last_clicked_longitude"] = None
                streamlit.session_state["last_clicked_latitude"] = None
                streamlit.rerun()
        else:
            streamlit.write("Kliknij na mapie, aby odczytać współrzędne (X,Y) i dodać punkt.")
    else:
        streamlit.warning("Interaktywne klikanie współrzędnych wymaga folium oraz streamlit-folium. Jeśli środowisko ich nie posiada, dodawaj punkty ręcznie lub z pliku.")

        polyline_layer = None
        if len(polyline_path) >= 4:
            polyline_layer = pydeck.Layer(
                "PathLayer",
                data=[{"path": polyline_path}],
                get_path="path",
                width_scale=8,
                width_min_pixels=2
            )

        points_layer = pydeck.Layer(
            "ScatterplotLayer",
            data=[{"longitude": float(row["longitude"]), "latitude": float(row["latitude"]), "fill_color": [0, 0, 0, 180]} for _, row in points_dataframe.iterrows()],
            get_position="[longitude, latitude]",
            get_radius=90,
            radius_min_pixels=4,
            get_fill_color="fill_color",
            pickable=True
        )

        centroid_layer = None
        if len(points_dataframe) > 0:
            centroid_layer = pydeck.Layer(
                "ScatterplotLayer",
                data=[{"longitude": float(centroid_longitude), "latitude": float(centroid_latitude), "fill_color": [255, 0, 0, 220]}],
                get_position="[longitude, latitude]",
                get_radius=260,
                radius_min_pixels=12,
                get_fill_color="fill_color",
                pickable=True
            )

        layers = []
        if polyline_layer is not None:
            layers.append(polyline_layer)
        layers.append(points_layer)
        if centroid_layer is not None:
            layers.append(centroid_layer)

        deck = pydeck.Deck(
            layers=layers,
            initial_view_state=pydeck.ViewState(
                longitude=float(map_center_longitude),
                latitude=float(map_center_latitude),
                zoom=11,
                pitch=0
            ),
            map_style=None
        )
        streamlit.pydeck_chart(deck, use_container_width=True)
